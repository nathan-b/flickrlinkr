<html>
<head>
	<link rel="stylesheet" type="text/css" href="style.css">
	<title>Magical land of happiness</title>
</head>

<body>

<h2>Put your flickr URLs here (one per line)</h2>
<textarea rows="8" cols="120" wrap="off" id="inbox">
</textarea><br /><br />

<button onclick="gogogo()">Do the thing</button>&nbsp;&nbsp;&nbsp;<button onclick="do_clear();">Clear the thing</button>&nbsp;&nbsp;&nbsp;

Image preferred size: <input type="text" size="7" value="800" id="size"></input> (Use 0 for largest available size)&nbsp;&nbsp;&nbsp;
<input type="checkbox" name='bbcode' id='bbcode'>Emit bbcode
<br /> <br />


<ul class="images" id="imglist">
</ul>

<br />

<span id="imgsel">
</span>

<h2>Your HTML will be emitted here</h2>

<textarea rows="25" cols="120" readonly id="outbox">
</textarea>

<h3>Ignore anything below this line</h3>
<textarea rows="10" cols="120" readonly id="console">
</textarea>

<script>
window.resizeTo(1024, 1024);
window.moveTo(0,0);

this.images = []

function do_clear()
{
	document.getElementById('inbox').value = '';
	document.getElementById('outbox').value = '';
	document.getElementById('console').value = '';
	this.images = '';
	clear_images();
}

// Fetch wrapper with retry logic for Flickr throttling
async function getrequest(url, callback, count)
{
	try {
		const response = await fetch(url);

		if (response.status === 200) {
			const text = await response.text();
			callback(url, text, count);
		} else if (response.status === 403) {
			// Flickr has started throttling with 403 errors, apparently. Just retry.
			window.setTimeout(() => getrequest(url, callback, count), 50);
		} else {
			print_console(`Received unexpected status ${response.status}`);
		}
	} catch (error) {
		print_console(`Network error fetching ${url}: ${error.message}`);
	}
}

// Some functions to print to our various textboxes (SUPAR LAZY PROGRAMMER GO)

function print_console(txt)
{
	const outelem = document.getElementById('console');
	outelem.value += `${txt}\n`
}

function print_outbox(txt)
{
	const outelem = document.getElementById('outbox');
	outelem.value += `${txt}\n`;
}

// Add and remove images from the images list

function add_image(url, idx)
{
	const listelem = document.getElementById('imglist');
	const li = document.createElement('li');
	const img = document.createElement('img');
	img.setAttribute('src', url);
	img.setAttribute('onclick', `load_img(${idx})`);
	li.appendChild(img);
	listelem.appendChild(li);
}

function clear_images()
{
	const listelem = document.getElementById('imglist');
	while (listelem.childNodes.length > 0) {
		listelem.removeChild(listelem.childNodes[0]);
	}
	window.images = [];
	clear_selected_image();
}

function clear_selected_image()
{
	const sel = document.getElementById('imgsel');

	while (sel.childNodes.length > 0) {
		sel.removeChild(sel.childNodes[0]);
	}
}

function get_size()
{
	let sz = parseInt(document.getElementById('size').value);
	if (!sz) {
		sz = 0;
	}
	return sz;
}

function build_html_string(disp_url, orig_url, width, height)
{
	return `<a href="${orig_url}"><img class="alignnone" src="${disp_url}" alt="" width="${width}" height="${height}" /></a>`
}

function build_bbcode_string(disp_url, orig_url, width, height)
{
	return `[url=${orig_url}][img width=${width}]${disp_url}[/img][/url]`
}

function load_img(idx)
{
	const img = window.images[idx];
	const sel = document.getElementById('imgsel');
	let outstr;
	document.getElementById('outbox').value = '';

	if (document.getElementById('bbcode').checked) {
		outstr = build_bbcode_string(img.disp_url, img.orig_url, img.disp_w, img.disp_h);
	} else {
		outstr = build_html_string(img.disp_url, img.orig_url, img.disp_w, img.disp_h);
	}

	print_outbox(outstr);
	print_outbox('');


	const i = document.createElement('img');
	i.setAttribute('src', img.preview);
	clear_selected_image();
	sel.appendChild(i);
}

this.max_retry_count = 10;

// Validate that URL has proper scheme and is a Flickr URL
function is_url_valid(url)
{
	// Check for http/https scheme
	if (!url.startsWith('http://') && !url.startsWith('https://')) {
		return false;
	}

	// Check if it's a Flickr domain
	try {
		const urlObj = new URL(url);
		const hostname = urlObj.hostname.toLowerCase();

		// Accept flickr.com, www.flickr.com, and flic.kr (Flickr's URL shortener)
		return hostname.endsWith('flickr.com') ||
		       hostname.endsWith('flic.kr');
	} catch (e) {
		// Invalid URL format
		return false;
	}
}

// Handle the response data as a text string
function process_one_url_response(url, txt, tries)
{
	print_console(`${url}: Got response with text length ${txt.length}`);

	// Extract the data from Flickr's page
	// Try multiple strategies to be robust against page structure changes
	let mxp = null;

	// Strategy 1: Look for Y.ClientApp.init( pattern (current Flickr format)
	const clientAppMatch = txt.match(/Y\.ClientApp\.init\s*\(/);
	if (clientAppMatch) {
		const startPos = clientAppMatch.index + clientAppMatch[0].length;
		// Find the matching closing parenthesis
		let depth = 1;
		let endPos = startPos;
		for (let i = startPos; i < txt.length && depth > 0; i++) {
			if (txt[i] === '(') depth++;
			if (txt[i] === ')') depth--;
			if (depth === 0) {
				endPos = i;
				break;
			}
		}
		if (depth === 0) {
			mxp = txt.substring(startPos, endPos);
		}
	}

	// Strategy 2: If Strategy 1 failed, look for modelExport directly
	if (!mxp) {
		const modelExportMatch = txt.match(/modelExport\s*:\s*\{/);
		if (modelExportMatch) {
			print_console(`${url}: Using fallback extraction method`);
			// Try to extract just the modelExport object
			// This is a simplified approach - look for the pattern in the initialization
			const initMatch = txt.match(/\{\s*initialView\s*:[\s\S]*?modelExport\s*:\s*(\{[\s\S]*?\})\s*,\s*auth\s*:/);
			if (initMatch && initMatch[1]) {
				mxp = `{modelExport: ${initMatch[1]}}`;
			}
		}
	}

	if (!mxp) {
		if (tries > this.max_retry_count) {
			print_console(`${url}: Could not find data in response after ${tries} attempts, aborting`);
			return;
		}
		print_console(`${url}: Retrying... (attempt ${tries + 1})`);
		getrequest(url, process_one_url_response, tries + 1);
		return;
	}

	let img;
	try {
		// Try parsing as JSON first (safest option)
		img = JSON.parse(mxp);
	} catch (e) {
		// If JSON parsing fails, the data is likely JavaScript object notation
		// Use Function constructor as a safer alternative to eval (no local scope access)
		// Define variables that Flickr's data might reference
		try {
			const func = new Function('auth', 'reqId', 'return ' + mxp);
			img = func('', '');
		} catch (e2) {
			print_console(`${url}: Failed to parse response data: ${e2.message}`);
			return;
		}
	}

	// Navigate the data structure safely
	// Flickr's new structure: modelExport.main['photo-models'][0].data.sizes.data
	if (!img || !img.modelExport || !img.modelExport.main || !img.modelExport.main['photo-models'] || !img.modelExport.main['photo-models'][0]) {
		print_console(`${url}: Unexpected data structure - cannot find photo-models`);
		return;
	}

	const photoModel = img.modelExport.main['photo-models'][0].data || img.modelExport.main['photo-models'][0];
	const sizesWrapper = photoModel.sizes;

	if (!sizesWrapper) {
		print_console(`${url}: Missing sizes object`);
		return;
	}

	// Sizes might be nested in a 'data' property (new format) or directly available (old format)
	const sizes = sizesWrapper.data || sizesWrapper;

	// flickr uses incomprehensible letters to represent its sizes. Forget that. Let's
	// just try and find one that matches the user-preferred size. 'o' is the original;
	// i.e. the largest size.
	const my_size = get_size();
	let best = 'o';  // If the user doesn't specify, just give the largest

	// Helper function to get size data (handles both old and new format)
	const getSizeData = (sizeKey) => {
		const sizeObj = sizes[sizeKey];
		return sizeObj && sizeObj.data ? sizeObj.data : sizeObj;
	};

	// Find the image with the size closest to the specified size, if given
	if (my_size > 0) {
		let best_diff = Number.MAX_SAFE_INTEGER;

		for (const k in sizes) {
			const sizeData = getSizeData(k);
			if (!sizeData) continue;

			const w = sizeData.width;
			const h = sizeData.height;

			if (Math.abs(my_size - w) < best_diff) {
				best = k;
				best_diff = Math.abs(my_size - w);
			}
			if (Math.abs(my_size - h) < best_diff) {
				best = k;
				best_diff = Math.abs(my_size - h);
			}
		}
	}

	const bestData = getSizeData(best);
	const origData = getSizeData('o');
	const sqData = getSizeData('sq');
	const nData = getSizeData('n');

	if (!bestData || !origData || !sqData || !nData) {
		print_console(`${url}: Missing required size data`);
		return;
	}

	print_console(`${url}: Best size is ${best}: ${bestData.width}x${bestData.height}`);
	print_console(`${url}: Original size is ${origData.width}x${origData.height}`);

	// We store a bunch of metadata about the image in the thumbnail list to avoid future lookups
	// It will be super fast right up until you start paging :)
	const thumb_url = `https:${sqData.displayUrl}`; // URL of the tiny thumbnail image
	const prev_url = `https:${nData.displayUrl}`;   // URL of the slightly larger preview image
	const disp_url = `https:${bestData.displayUrl}`;      // URL to be displayed (i.e. the size the user specified)
	const orig_url = `https:${origData.displayUrl}`;       // URL to be linked (i.e. the original quality image)
	const disp_w = bestData.width;
	const disp_h = bestData.height;

	// Stick the new image on the end of the global images array. The index in the array is associated with the image
	// stored in the image list so we can grab all this metadata whenever the user clicks on an image in the list
	const idx = window.images.length;
	window.images.push({ disp_url: disp_url, orig_url: orig_url, preview: prev_url, disp_w: disp_w, disp_h: disp_h });

	// Build and display the string. Why do it here? Because that way the user will have a convenient list of all the strings
	// immediately after processing.
	let outstr;

	if (document.getElementById('bbcode').checked) {
		outstr = build_bbcode_string(disp_url, orig_url, disp_w, disp_h);
	} else {
		outstr = build_html_string(disp_url, orig_url, disp_w, disp_h);
	}
	print_outbox(outstr);
	print_outbox('');

	// Add the image to the image list
	add_image(thumb_url, idx);

	// Clear the input box for the next list of images
	document.getElementById('inbox').value='';
}

function gogogo()
{
	const urlelem = document.getElementById('inbox');
	const urls = urlelem.value.split("\n");

	print_console(`Starting with ${urls.length} urls`);

	for (let i = 0; i < urls.length; ++i) {
		if (urls[i].length == 0) continue;

		if (!is_url_valid(urls[i])) {
			print_console(`Invalid URL (must be a Flickr URL from flickr.com or flic.kr): ${urls[i]}`);
			continue;
		}

		getrequest(urls[i], process_one_url_response, 0);
	}
}

</script>

</body>
